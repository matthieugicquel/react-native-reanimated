"use strict";(self.webpackChunkdocs_reanimated=self.webpackChunkdocs_reanimated||[]).push([[8931],{82885:(e,t,n)=>{n.d(t,{A:()=>d});var a=n(96540),i=n(9176),l=n(62257),s=n(72188),r=n(55535);const o={code:"function AnimatingStylesTsx1(){const{withSpring,translateX}=this.__closure;return{transform:[{translateX:withSpring(translateX.value*2)}]};}"};function d(){const e=(0,r.useSharedValue)(0),t=(0,r.useAnimatedStyle)(function(){const t=()=>({transform:[{translateX:(0,r.withSpring)(2*e.value)}]});return t.__closure={withSpring:r.withSpring,translateX:e},t.__workletHash=0xf16af34d7f,t.__initData=o,t}());return a.createElement(a.Fragment,null,a.createElement(r.default.View,{style:[y.box,t]}),a.createElement(i.A,{style:y.container},a.createElement(l.A,{onPress:()=>{e.value+=50},title:"Click me"})))}const y=s.A.create({container:{flex:1,alignItems:"center",justifyContent:"center"},box:{height:120,width:120,backgroundColor:"#b58df1",borderRadius:20,marginVertical:50}})},78827:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>y,contentTitle:()=>o,default:()=>b,frontMatter:()=>r,metadata:()=>d,toc:()=>u});var a=n(58168),i=(n(96540),n(15680)),l=n(82885),s=n(3750);const r={sidebar_position:2},o="useAnimatedStyle",d={unversionedId:"core/useAnimatedStyle",id:"core/useAnimatedStyle",title:"useAnimatedStyle",description:"useAnimatedStyle lets you create a styles object, similar to StyleSheet styles, which can be animated using shared values.",source:"@site/docs/core/useAnimatedStyle.mdx",sourceDirName:"core",slug:"/core/useAnimatedStyle",permalink:"/react-native-reanimated/docs/next/core/useAnimatedStyle",draft:!1,editUrl:"https://github.com/software-mansion/react-native-reanimated/edit/main/packages/docs-reanimated/docs/core/useAnimatedStyle.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"useSharedValue",permalink:"/react-native-reanimated/docs/next/core/useSharedValue"},next:{title:"useAnimatedProps",permalink:"/react-native-reanimated/docs/next/core/useAnimatedProps"}},y={},u=[{value:"Reference",id:"reference",level:2},{value:"Arguments",id:"arguments",level:3},{value:"<code>updater</code>",id:"updater",level:4},{value:"<code>dependencies</code> <Optional/>",id:"dependencies-",level:4},{value:"Returns",id:"returns",level:2},{value:"Example",id:"example",level:2},{value:"Remarks",id:"remarks",level:2},{value:"Platform compatibility",id:"platform-compatibility",level:2}],m=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.yg)("div",t)},p=m("Optional"),c=m("InteractiveExample"),g=m("Indent"),h=m("PlatformCompatibility"),f={toc:u},v="wrapper";function b(e){let{components:t,...n}=e;return(0,i.yg)(v,(0,a.A)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"useanimatedstyle"},"useAnimatedStyle"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"useAnimatedStyle")," lets you create a styles object, similar to ",(0,i.yg)("inlineCode",{parentName:"p"},"StyleSheet")," styles, which can be animated using ",(0,i.yg)("a",{parentName:"p",href:"/docs/next/fundamentals/glossary#shared-value"},"shared values"),"."),(0,i.yg)("p",null,"Styles defined using ",(0,i.yg)("inlineCode",{parentName:"p"},"useAnimatedStyle")," have to be passed to ",(0,i.yg)("inlineCode",{parentName:"p"},"style")," property of an ",(0,i.yg)("a",{parentName:"p",href:"/docs/next/fundamentals/glossary#animated-component"},"Animated component"),". Styles are automatically updated whenever an associated shared value or React state changes."),(0,i.yg)("p",null,"In contrast to the ",(0,i.yg)("a",{parentName:"p",href:"/docs/next/fundamentals/glossary#animations-in-inline-styling"},"inline styling"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"useAnimatedStyle")," allows to ",(0,i.yg)("a",{parentName:"p",href:"/docs/next/fundamentals/animating-styles-and-props/#animating-styles"},"access values stored in shared values")," in the styles object it defines."),(0,i.yg)("p",null,"For animating properties use ",(0,i.yg)("a",{parentName:"p",href:"/docs/next/core/useAnimatedProps"},(0,i.yg)("inlineCode",{parentName:"a"},"useAnimatedProps"))," instead."),(0,i.yg)("h2",{id:"reference"},"Reference"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-jsx"},"import { useAnimatedStyle } from 'react-native-reanimated';\n\nfunction App() {\n  // highlight-next-line\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      opacity: sv.value ? 1 : 0,\n    };\n    // highlight-next-line\n  });\n\n  // highlight-next-line\n  return <Animated.View style={[styles.box, animatedStyles]} />;\n}\n")),(0,i.yg)("details",null,(0,i.yg)("summary",null,"Type definitions"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-typescript"},"type DefaultStyle = ViewStyle | ImageStyle | TextStyle;\ntype DependencyList = Array<unknown> | undefined;\n\nexport function useAnimatedStyle<Style extends DefaultStyle>(\n  updater: () => Style,\n  dependencies?: DependencyList | null\n): Style;\n"))),(0,i.yg)("h3",{id:"arguments"},"Arguments"),(0,i.yg)("h4",{id:"updater"},(0,i.yg)("inlineCode",{parentName:"h4"},"updater")),(0,i.yg)("p",null,"A function returning an object with style properties you want to animate. You can animate any style property available in React Native."),(0,i.yg)("h4",{id:"dependencies-"},(0,i.yg)("inlineCode",{parentName:"h4"},"dependencies")," ",(0,i.yg)(p,{mdxType:"Optional"})),(0,i.yg)("p",null,"An optional array of dependencies."),(0,i.yg)("p",null,"Only relevant when using Reanimated ",(0,i.yg)("a",{parentName:"p",href:"https://docs.swmansion.com/react-native-reanimated/docs/guides/web-support#web-without-the-babel-plugin"},"without the Babel plugin on the Web"),"."),(0,i.yg)("h2",{id:"returns"},"Returns"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"useAnimatedStyle")," returns an animated style object which has to be passed to the ",(0,i.yg)("inlineCode",{parentName:"p"},"style")," property of an ",(0,i.yg)("a",{parentName:"p",href:"/docs/next/fundamentals/glossary#animated-component"},"Animated component")," that you want to animate."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"useAnimatedStyle")," mimics the behavior of ",(0,i.yg)("inlineCode",{parentName:"p"},"StyleSheet")," as much as possible. ",(0,i.yg)("inlineCode",{parentName:"p"},"updater")," callback returns a value that looks like a regular style object in which you can also use shared values."),(0,i.yg)("h2",{id:"example"},"Example"),(0,i.yg)(c,{src:s.A,component:l.A,showCode:!0,mdxType:"InteractiveExample"}),(0,i.yg)("h2",{id:"remarks"},"Remarks"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Animated styles take precedence over React Native's static styles. All values specified in animated styles override values from static styles.")),(0,i.yg)(g,{mdxType:"Indent"},(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-jsx"},"function App() {\n  const animatedStyles = useAnimatedStyle(() => ({\n    width: sv.value,\n  }));\n\n  return (\n    <Animated.View\n      style={[\n        // highlight-start\n        animatedStyles, // \u26a0\ufe0f overrides the static style width\n        { width: 100 },\n        // highlight-end\n      ]}\n    />\n  );\n}\n"))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"Animated styles don't follow the order in which they are specified in the style array. The last updated animated style is the one that takes effect.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"Removing the animated style from the view doesn't unset values that were applied in the animated style. To unset these values, you need to manually set them to ",(0,i.yg)("inlineCode",{parentName:"p"},"undefined")," in the animated style.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"Mutating shared values in ",(0,i.yg)("inlineCode",{parentName:"p"},"useAnimatedStyle"),"'s callback is an undefined behavior which may lead to infinite loops."))),(0,i.yg)(g,{mdxType:"Indent"},(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-jsx"},"function App() {\n  const sv = useSharedValue(0);\n  const animatedStyles = useAnimatedStyle(() => {\n    // highlight-next-line\n    sv.value = withTiming(1); // Don't do this!\n    return { opacity: sv.value };\n  });\n}\n"))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"You can apply the value returned from ",(0,i.yg)("inlineCode",{parentName:"p"},"useAnimatedStyle")," only to ",(0,i.yg)("inlineCode",{parentName:"p"},"Animated")," components. Passing the animated styles to non-animated component will result in an error.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"Only define the dynamic part of your styles with ",(0,i.yg)("inlineCode",{parentName:"p"},"useAnimatedStyle")," and keep the static ones separately using ",(0,i.yg)("inlineCode",{parentName:"p"},"StyleSheet")," API or (if you really have to) with inline styles. That way you avoid lots of unnecessary style recalculations. Static and dynamic styles can be easily merged using the ",(0,i.yg)("inlineCode",{parentName:"p"},"[]")," syntax:"))),(0,i.yg)(g,{mdxType:"Indent"},(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-jsx"},"function App() {\n  const animatedStyles = useAnimatedStyle(() => ({\n    offset: sv.value,\n  }));\n\n  // highlight-next-line\n  return <Animated.View style={[styles.box, animatedStyles]} />;\n}\n\nconst styles = StyleSheet.create({\n  box: {\n    height: 120,\n    width: 120,\n    backgroundColor: '#b58df1',\n  },\n});\n"))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"You can share animated styles between components to avoid code duplication.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"The callback passed to the ",(0,i.yg)("inlineCode",{parentName:"p"},"useAnimatedStyle")," is first run on the ",(0,i.yg)("a",{parentName:"p",href:"/docs/next/fundamentals/glossary#javascript-thread"},"JavaScript thread")," and immediately after on the ",(0,i.yg)("a",{parentName:"p",href:"/docs/next/fundamentals/glossary#ui-thread"},"UI thread"),". This may cause an error if you write your code as if it's running on UI thread only. To avoid this, you can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"global._WORKLET")," variable to check if the code is running on the UI thread:"))),(0,i.yg)(g,{mdxType:"Indent"},(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-jsx"},"function App() {\n  const animatedStyles = useAnimatedStyle(() => {\n    // highlight-next-line\n    if (global._WORKLET) {\n      // UI thread only code\n    } else {\n      // JS thread fallback code\n    }\n  });\n}\n"))),(0,i.yg)("h2",{id:"platform-compatibility"},"Platform compatibility"),(0,i.yg)(h,{android:!0,ios:!0,web:!0,mdxType:"PlatformCompatibility"}))}b.isMDXComponent=!0},3750:(e,t,n)=>{n.d(t,{A:()=>a});const a="import React from 'react';\nimport { Button, View, StyleSheet } from 'react-native';\nimport Animated, {\n  useSharedValue,\n  withSpring,\n  useAnimatedStyle,\n} from 'react-native-reanimated';\n\nexport default function App() {\n  const translateX = useSharedValue<number>(0);\n\n  const handlePress = () => {\n    translateX.value += 50;\n  };\n\n  // highlight-start\n  const animatedStyles = useAnimatedStyle(() => ({\n    transform: [{ translateX: withSpring(translateX.value * 2) }],\n  }));\n  // highlight-end\n\n  return (\n    <>\n      {/* highlight-next-line */}\n      <Animated.View style={[styles.box, animatedStyles]} />\n      <View style={styles.container}>\n        <Button onPress={handlePress} title=\"Click me\" />\n      </View>\n    </>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    height: 120,\n    width: 120,\n    backgroundColor: '#b58df1',\n    borderRadius: 20,\n    marginVertical: 50,\n  },\n});\n"},62257:(e,t,n)=>{n.d(t,{A:()=>d});var a=n(96540),i=n(72188),l=n(46413),s=n(78506),r=a.forwardRef(((e,t)=>{var n=e.accessibilityLabel,i=e.color,r=e.disabled,d=e.onPress,y=e.testID,u=e.title;return a.createElement(l.A,{accessibilityLabel:n,accessibilityRole:"button",disabled:r,focusable:!r,onPress:d,ref:t,style:[o.button,i&&{backgroundColor:i},r&&o.buttonDisabled],testID:y},a.createElement(s.A,{style:[o.text,r&&o.textDisabled]},u))}));r.displayName="Button";var o=i.A.create({button:{backgroundColor:"#2196F3",borderRadius:2},text:{color:"#fff",fontWeight:"500",padding:8,textAlign:"center",textTransform:"uppercase"},buttonDisabled:{backgroundColor:"#dfdfdf"},textDisabled:{color:"#a1a1a1"}});const d=r}}]);